{\rtf1\ansi\ansicpg1252\cocoartf2709
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 HelveticaNeue-Bold;\f1\fnil\fcharset0 HelveticaNeue;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;\red255\green255\blue255;\red30\green30\blue30;\red89\green138\blue67;
\red255\green255\blue255;\red202\green202\blue202;\red70\green137\blue204;\red67\green192\blue160;\red212\green214\blue154;
\red167\green197\blue152;}
{\*\expandedcolortbl;;\cssrgb\c100000\c100000\c100000;\cssrgb\c15686\c15686\c15686;\cssrgb\c41569\c60000\c33333;
\cssrgb\c100000\c100000\c100000\c10196;\cssrgb\c83137\c83137\c83137;\cssrgb\c33725\c61176\c83922;\cssrgb\c30588\c78824\c69020;\cssrgb\c86275\c86275\c66667;
\cssrgb\c70980\c80784\c65882;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Intuition\
\pard\pardeftab720\sa240\partightenfactor0

\f1\b0\fs24 \cf2 My initial idea is to initially count the total number of nodes in the list. Then, by subtracting 'n' from this count, we can determine the position of the element we want to remove.\
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs36 \cf2 Approach\
\pard\pardeftab720\sa240\partightenfactor0

\f1\b0\fs24 \cf2 My approach begins by first determining the number of nodes in the list. To achieve this, I employed a temporary variable to traverse the list, incrementing the count value for each node until the next value for a particular node becomes 'None.'\
Next, I introduced a variable 'j' to locate the node that precedes the one we intend to remove. In cases where the list contains only one node, the only option is to remove that node itself. In such instances, I set 'head' to 'None.' If 'j' equals '0,' it signifies that we need to remove the first element. In this scenario, I simply updated 'head' to 'head.next,' effectively deleting the first node.\
The pivotal step in this process involves traversing the list until reaching the node just before the one to be deleted. I achieved this by navigating through the 'before' variable until I reached the target node, then unlinking the node slated for removal from its preceding element.\
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs36 \cf2 Complexity\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\partightenfactor0
\ls1\ilvl0
\f1\b0\fs24 \cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Time complexity:\cb1 \uc0\u8232 \cb3 O(2n) in worst case scenario\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Space complexity:\cb1 \uc0\u8232 \cb3 O(1)\cb1 \
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Code\
\pard\pardeftab720\partightenfactor0

\f2\b0\fs26 \cf4 \cb5 \strokec4 # Definition for singly-linked list.\cf6 \strokec6 \
\cf4 \strokec4 # class ListNode:\cf6 \strokec6 \
\cf4 \strokec4 #     def __init__(self, val=0, next=None):\cf6 \strokec6 \
\cf4 \strokec4 #         self.val = val\cf6 \strokec6 \
\cf4 \strokec4 #         self.next = next\cf6 \strokec6 \
\pard\pardeftab720\partightenfactor0
\cf7 \strokec7 class\cf6 \strokec6  \cf8 \strokec8 Solution\cf6 \strokec6 :\
    \cf7 \strokec7 def\cf6 \strokec6  \cf9 \strokec9 removeNthFromEnd\cf6 \strokec6 (\cf7 \strokec7 self\cf6 \strokec6 , \cf10 \strokec10 head\cf6 \strokec6 : Optional[ListNode], \cf10 \strokec10 n\cf6 \strokec6 : int) -> Optional[ListNode]:\
       before=temp=head\
      \
       count=\cf10 \strokec10 1\cf6 \strokec6 \
       \cf7 \strokec7 while\cf6 \strokec6 (temp.\cf7 \strokec7 next\cf6 \strokec6 ):\
           count+=\cf10 \strokec10 1\cf6 \strokec6 \
           temp=temp.\cf7 \strokec7 next\cf6 \strokec6 \
       j=count-n\
       \cf7 \strokec7 if\cf6 \strokec6  count==\cf10 \strokec10 1\cf6 \strokec6 :\
          head=None\
       \cf7 \strokec7 if\cf6 \strokec6  j==\cf10 \strokec10 0\cf6 \strokec6 :\
          \cf7 \strokec7 if\cf6 \strokec6 (head):\
             head=head.\cf7 \strokec7 next\cf6 \strokec6 \
       \cf7 \strokec7 for\cf6 \strokec6  i \cf7 \strokec7 in\cf6 \strokec6  range(j-\cf10 \strokec10 1\cf6 \strokec6 ):\
          before=before.\cf7 \strokec7 next\cf6 \strokec6 \
       \cf7 \strokec7 if\cf6 \strokec6 (before.\cf7 \strokec7 next\cf6 \strokec6  != None):\
          before.\cf7 \strokec7 next\cf6 \strokec6 =before.\cf7 \strokec7 next\cf6 \strokec6 .\cf7 \strokec7 next\cf6 \strokec6 \
      \
       \cf10 \strokec10 else\cf6 \strokec6 :\
          before.\cf7 \strokec7 next\cf6 \strokec6 =None\
      \
       \cf7 \strokec7 return\cf6 \strokec6  head\
\
        \
    \
    \
    \
    \
\
    \
        \
\
\
\
    \
    \
      \
\
              \
\
\
\
\
        \
\
    \cb1 \
}