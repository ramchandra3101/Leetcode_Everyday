Intuition
My initial idea is to initially count the total number of nodes in the list. Then, by subtracting 'n' from this count, we can determine the position of the element we want to remove.

Approach
My approach begins by first determining the number of nodes in the list. To achieve this, I employed a temporary variable to traverse the list, incrementing the count value for each node until the next value for a particular node becomes 'None.'

Next, I introduced a variable 'j' to locate the node that precedes the one we intend to remove. In cases where the list contains only one node, the only option is to remove that node itself. In such instances, I set 'head' to 'None.' If 'j' equals '0,' it signifies that we need to remove the first element. In this scenario, I simply updated 'head' to 'head.next,' effectively deleting the first node.

The pivotal step in this process involves traversing the list until reaching the node just before the one to be deleted. I achieved this by navigating through the 'before' variable until I reached the target node, then unlinking the node slated for removal from its preceding element.

Complexity
Time complexity:
O(2n) in worst case scenario

Space complexity:
O(1)

Code
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
       before=temp=head
      
       count=1
       while(temp.next):
           count+=1
           temp=temp.next
       j=count-n
       if count==1:
          head=None
       if j==0:
          if(head):
             head=head.next
       for i in range(j-1):
          before=before.next
       if(before.next != None):
          before.next=before.next.next
      
       return head
